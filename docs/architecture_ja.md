# アーキテクチャガイド

## 概要

この FastAPI アプリケーションは、クリーンアーキテクチャアプローチでドメイン駆動設計（DDD）の原則に従います。コードベースは、それぞれ特定の責任を持つ明確な層に整理されています。

## アーキテクチャ層

### 1. ドメイン層（`app/domain/`）

ビジネスロジックの中核となる層：

- **エンティティ**（`entities/`）：コアビジネスオブジェクト
  - `User`：ロールと認証を伴うユーザー管理
  - `Post`：ステータスと公開機能を持つコンテンツ管理

- **リポジトリ**（`repositories/`）：データアクセスの抽象インターフェース
  - `UserRepository`：ユーザーデータアクセスインターフェース
  - `PostRepository`：投稿データアクセスインターフェース

- **サービス**（`services/`）：ビジネスロジックとドメインルール
  - `UserService`：ユーザー関連のビジネス操作
  - `PostService`：投稿関連のビジネス操作

### 2. アプリケーション層（`app/application/`）

ドメインオブジェクトを調整し、ユースケースを実装：

- **ユースケース**（`use_cases/`）：アプリケーション固有のビジネスロジック
  - `AuthUseCases`：認証・認可ワークフロー
  - `UserUseCases`：ユーザー管理ワークフロー
  - `PostUseCases`：コンテンツ管理ワークフロー

### 3. インフラストラクチャ層（`app/infrastructure/`）

外部の関心事を実装：

- **リポジトリ**（`repositories/`）：ドメインリポジトリの具象実装
  - `SQLUserRepository`：PostgreSQL/SQLite 実装
  - `SQLPostRepository`：PostgreSQL/SQLite 実装

- **データベース**（`database/`）：データベース固有の実装
- **外部サービス**（`external/`）：サードパーティサービス統合
- **タスク**（`tasks/`）：バックグラウンドタスク実装

### 4. プレゼンテーション層（`app/presentation/`）

外部通信を処理：

- **API**（`api/`）：REST API エンドポイント
  - `auth.py`：認証エンドポイント
  - `users.py`：ユーザー管理エンドポイント
  - `posts.py`：コンテンツ管理エンドポイント

- **スキーマ**（`schemas/`）：リクエスト/レスポンスモデル
  - API バリデーション用の Pydantic モデル
  - データ転送オブジェクト（DTO）

- **依存関係**（`dependencies/`）：依存性注入
  - 認証依存関係
  - データベースセッション管理

### 5. コア層（`app/core/`）

横断的関心事：

- `config.py`：アプリケーション設定
- `database.py`：データベース接続とセッション管理
- `security.py`：認証・暗号化ユーティリティ
- `logging.py`：構造化ログ設定

## 主要な設計パターン

### 依存関係逆転

- 高レベルモジュールは低レベルモジュールに依存しない
- 両方とも抽象化（インターフェース）に依存
- 抽象化は詳細に依存しない

### リポジトリパターン

- データアクセスロジックをカプセル化
- データ操作の統一インターフェースを提供
- モック実装による簡単なテストを可能にする

### ユースケースパターン

- アプリケーション固有のビジネスルールをカプセル化
- 特定の要件を満たすためにドメインオブジェクトを調整
- アプリケーション機能の明確なエントリーポイントを提供

### 依存性注入

- 実行時に依存関係を注入
- 疎結合とテスト容易性を実現
- FastAPI の依存関係システムを使用して実装

## データフロー

```
HTTP リクエスト → API ルーター → ユースケース → ドメインサービス → リポジトリ → データベース
                      ↓
レスポンススキーマ ← ユースケース ← ドメインエンティティ ← リポジトリ ← データベース
```

1. **リクエスト**：HTTP リクエストが API エンドポイントに到着
2. **ルーティング**：FastAPI が適切なハンドラーにルーティング
3. **バリデーション**：Pydantic がリクエストデータを検証
4. **ユースケース**：アプリケーション層がビジネスロジックを調整
5. **ドメイン**：ビジネスルールが適用される
6. **リポジトリ**：データが永続化または取得される
7. **レスポンス**：結果がフォーマットされて返される

## データベース設計

### エンティティ関係

```
User (1) → (N) Post
  ↓
  UserRole (Enum)

Post → PostStatus (Enum)
```

### 主要エンティティ

- **User**：認証、認可、プロフィール管理
- **Post**：コンテンツ作成、公開ワークフロー、ステータス管理

## セキュリティアーキテクチャ

### 認証フロー

1. ユーザーが認証情報を提供
2. システムがデータベースに対して検証
3. JWT トークンが生成される（アクセス + リフレッシュ）
4. トークンが後続のリクエストで使用される
5. 保護されたエンドポイントでトークンが検証される

### 認可レベル

- **USER**：基本的なユーザー操作
- **MODERATOR**：コンテンツモデレーション機能
- **ADMIN**：完全なシステム管理

## スケーラビリティの考慮事項

### 水平スケーリング

- ステートレスなアプリケーション設計
- データベース接続プーリング
- JWT によるセッションベース認証

### パフォーマンス最適化

- I/O 操作の async/await
- データベースクエリ最適化
- キャッシュ戦略（Redis 統合準備済み）
- コネクションプーリング

### 監視・可観測性

- コンテキストを含む構造化ログ
- Prometheus メトリクス統合
- ヘルスチェックエンドポイント
- エラー追跡とアラート

## テスト戦略

### ユニットテスト

- ドメインロジックテスト
- サービス層テスト
- リポジトリインターフェーステスト

### 統合テスト

- API エンドポイントテスト
- データベース統合テスト
- 外部サービステスト

### テストデータベース

- 高速テスト実行のための SQLite
- 分離されたテストフィクスチャとデータ
- 独立したテスト環境

## 開発原則

1. **単一責任原則**：各クラスは変更する理由が1つ
2. **開放閉鎖原則**：拡張に対しては開放、修正に対しては閉鎖
3. **リスコフ置換原則**：サブタイプは基本型で置換可能でなければならない
4. **インターフェース分離原則**：1つの汎用インターフェースより多くの特定インターフェース
5. **依存関係逆転原則**：具象ではなく抽象に依存する

## マイグレーション戦略

### データベースマイグレーション

- スキーマバージョニングの Alembic
- 自動マイグレーション生成
- ロールバック機能
- 環境固有のマイグレーション

### アプリケーション更新

- ブルーグリーンデプロイメントサポート
- データベースマイグレーション自動化
- ヘルスチェック統合
- グレースフルシャットダウン処理